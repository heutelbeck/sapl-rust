/*
    Copyright 2025 Stefan Weng

    Licensed under the Apache License, Version 2.0 (the "License"); you may not
    use this file except in compliance with the License. You may obtain a copy
    of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
    License for the specific language governing permissions and limitations
    under the License.
*/

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

COMMENT = _{ line_comment | block_comment }

line_comment = _{ " //" ~ (!"\n" ~ ANY)* }

block_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

sapl_document = _{ SOI ~ document ~ EOI }

document = _{ import_statement* ~ schema* ~ policy_element }

import_statement = { "import" ~ (wildcard_import | library_import | function_import) }

wildcard_import = @{ sapl_id ~ ("." ~ sapl_id)* ~ "." ~ "*" }

library_import = { sapl_id ~ ("." ~ sapl_id)* ~ "as" ~ sapl_id }

function_import = @{ sapl_id ~ ("." ~ sapl_id)* }

schema = { schema_entry }

schema_entry = _{ sapl_id ~ ("enforced")? ~ "schema" ~ expression }

policy_element = _{ policy_set | policy }

policy_set = { "set" ~ policy_set_name ~ combining_algorithm ~ ("for" ~ target_expression)? ~ (variable_assignment ~ ";")* ~ policy+ }

combining_algorithm = {
    "deny-overrides"
  | "permit-overrides"
  | "first-applicable"
  | "only-one-applicable"
  | "deny-unless-permit"
  | "permit-unless-deny"
}

policy_set_name = @{ string }

statement = _{ !("where" | "transform" | "advice" | "obligation") ~ (variable_assignment | condition) ~ ";"* }

variable_assignment = { "var" ~ id ~ "=" ~ expression ~ ("schema" ~ expression ~ ("," ~ expression)*)? }

condition = { expression }

entitlement = { "permit" | "deny" }

policy_name = @{ string }

where_statement = { ("where" ~ statement ~ (statement)*) }

transformation = { ("transform" ~ expression) }

advice = { advice_entry }

advice_entry = { "advice" ~ expression }

obligation = { ("obligation" ~ expression) }

policy = {
    "policy" ~ policy_name ~ entitlement ~ target_expression? ~ where_statement? ~ obligation? ~ advice? ~ transformation?
}

target_expression = { !("policy" | "where" | "transform" | "advice" | "obligation") ~ expression }

expression = _{ atom ~ (op ~ atom)* }

atom = _{ unary_expression? ~ primary }

primary = _{ basic_expression | "(" ~ expression ~ ")" }

op = _{ lazy_or | lazy_and | eager_or | exclusive_or | eager_and | equal | not_equal | regex | comparison | less_equal | greater_equal | less | greater | addition | subtract | mul | div | modulo }

lazy_or = { "||" }

lazy_and = { "&&" }

eager_or = { "|" }

exclusive_or = { "^" }

eager_and = { "&" }

equal = { "==" }

not_equal = { "!=" }

regex = { "=~" }

comparison = { "in" }

less = { "<" }

greater = { ">" }

less_equal = { "<=" }

greater_equal = { ">=" }

addition = { "+" }

subtract = { "-" }

mul = { "*" }

div = { "/" }

modulo = { "%" }

unary_expression = { ("!" | "-" | "+") }

basic_expression = _{ basic ~ (FILTER ~ filter_component | SUBTEMPLATE ~ basic_expression)? }

filter_component = @{ "each"? ~ sapl_id ~ ("." ~ sapl_id)* ~ arguments? | "{" ~ filter_statement ~ ("," ~ filter_statement)* ~ "}" }

filter_statement = { "each"? ~ "@"? ~ ":" ~ sapl_id ~ ("." ~ sapl_id)* ~ arguments? }

arguments = { "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

basic = _{
    basic_group
  | basic_value
  | basic_function
  | basic_environment_attribute
  | basic_environment_head_attribute
  | basic_identifier
  | basic_relative
}

basic_group = { "(" ~ expression ~ ")" ~ step* }

basic_value = _{ value ~ step* }

basic_function = { function_identifier ~ arguments ~ step* }

basic_environment_attribute = { "<" ~ function_identifier ~ arguments? ~ ">" ~ step* }

basic_environment_head_attribute = { "|<" ~ function_identifier ~ arguments? ~ ">" ~ step* }

basic_identifier = { sapl_id ~ step* }

basic_relative = { "@" ~ step* }

function_identifier = { id ~ ("." ~ sapl_id)* }

value = _{ pairs | array | number_literal | string_literal | boolean_literal | null_literal | undefined_literal }

pairs = { "{" ~ (pair ~ ("," ~ pair)*)? ~ "}" }

pair = { string ~ ":" ~ expression }

array = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }

number_literal = _{ integer | float }

integer = @{ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) ~ !"." }

float = @{ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* ~ ("." ~ ASCII_DIGIT+)? ~ (("E" | "e") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }

JSONNUMBER = { ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) ~ ("." ~ ASCII_DIGIT+)? ~ (("E" | "e") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }

string_literal = _{ string }

boolean_literal = { "true" | "false" }

null_literal = { "null" }

undefined_literal = { "undefined" }

step = _{
    "." ~ (key_step | escaped_key_step | wildcard_step | attribute_finder_step | head_attribute_finder_step)
  | "[" ~ subscript ~ "]"
  | ".." ~ (recursive_key_step | recursive_wildcard_step | recursive_index_step)
}

key_step = @{ sapl_id }

escaped_key_step = @{ string }

wildcard_step = { "*" }

attribute_finder_step = @{ "<" ~ sapl_id ~ ("." ~ sapl_id)* ~ arguments? ~ ">" }

head_attribute_finder_step = @{ "|<" ~ sapl_id ~ ("." ~ sapl_id)* ~ arguments? ~ ">" }

recursive_key_step = @{ sapl_id | "[" ~ string ~ "]" }

recursive_wildcard_step = @{ "*" | "[" ~ "*" ~ "]" }

recursive_index_step = @{ "[" ~ signed_number ~ "]" }

subscript = { string | "*" | signed_number | signed_number? ~ ":" ~ signed_number? ~ (":" ~ signed_number)? | "(" ~ expression ~ ")" | "?" ~ "(" ~ expression ~ ")" | signed_number ~ ("," ~ signed_number)* | string ~ ("," ~ string)* }

signed_number = { "-"? ~ JSONNUMBER }

sapl_id = _{ basic_identifier_expression | id }

basic_identifier_expression = { "subject" | "action" | "resource" | "environment" }

id = @{ "^"? ~ (ASCII_ALPHA | "_" | "$") ~ (ASCII_ALPHA | "_" | "$" | ASCII_DIGIT)* }

string = { "\"" ~ ("\\" | (!"\"" ~ ANY))* ~ "\"" }

FILTER = { "|-" }

SUBTEMPLATE = { "::" }
